terminal list:
epsilon
let
delim
string
number
boolean
char
comma
+
-
*
/
%
=
< 
>
<=
>=
==
!=
and
or

non-terminal list:
VARDEC
VARNAME 
INITIAL
VALUE
SET_OF_VALUES
ARRAY
OPERATOR 
CONDITION
CONJUNCTION
OBJ
STATEMENT
EXPRESSION
ARGUMENTS
PARAMETERS
FUNCTION_NAME
FUNCTION
FUNCTION_CALL
BLOCK
NESTED_IF
LOOP
WHILE_LOOP
DO_WHILE_LOOP
FOR_LOOP
PATH
OUTPUT
INPUT

production list:
epsilon => grammar terminator 
VARDEC => let VARNAME delim | let VARNAME = INITIAL 
VARNAME => string starting with an alphabet character
INITIAL => VALUE delim | ARRAY delim | FUNCTION_CALL delim
VALUE => string | number | boolean | char
SET_OF_VALUES => VALUE | VALUE comma SET_OF_VALUES
ARRAY => [SET_OF_VALUES]
OPERATOR => + | - | * | / | % | = 
CONDITION => < | > | <= | >= | == | !=
CONJUNCTION => and | or   
OBJ => VARNAME | VALUE 
STATEMENT => OBJ CONDITION OBJ | STATEMENT CONJUNCTION OBJ CONDITION OBJ CONJUNCTION STATEMENT | boolean | epsilon
EXPRESSION => OBJ OPERATOR OBJ delim | OBJ OPERATOR OBJ EXPRESSION | VARNAME OPRATOR FUNCTION_CALL delim
ARGUMENTS => OBJ | OBJ comma ARGUMENTS | EXPRESSION | epsilon
PARAMETERS => VARNAME | VARNAME comma PARAMETERS | epsilon
FUNCTION_NAME => string starting with an alphabet character 
FUNCTION => fn FUNCTION_NAME(PARAMETERS) { BLOCK }
FUNCTION_CALL => FUNCTION_NAME(ARGUMENTS)
BLOCK => return STATEMENT delim BLOCK | VARDEC BLOCK | NESTED_IF BLOCK | LOOP BLOCK | OUTPUT BLOCK | INPUT BLOCK | epsilon 
NESTED_IF => if(STATEMENT) { BLOCK } NESTED_IF | else if(STATEMENT) { BLOCK } NESTED_IF | else { BLOCK } | epsilon
LOOP => WHILE_LOOP | FOR_LOOP | DO_WHILE_LOOP
WHILE_LOOP => while(statement) { BLOCK }
DO_WHILE_LOOP => do_while(statement) { BLOCK }
FOR_LOOP => for(VARDEC delim STATEMENT delim EXPRESSION) { BLOCK } | for(EXPRESSION delim STATEMENT delim EXPRESSION) { BLOCK }
PATH => string
OUTPUT => out(OBJ, PATH) delim
INPUT => in(VARNAME, PATH) delim
CONCAT => concat(OBJ, OBJ)
ARRAY_LENGTH => arrlen(OBJ)
STRING_LENGTH => strlen(OBJ)

sample codes :
hello_world.fl :
	out("Hello World\n", output.txt);
one_to_ten.fl:
	for(let i = 1; i <= 10; i++) {
		out(concat(i, "\n"), output.txt);
	}
fibonacci.fl:
	fn fibonacci(n) {
		if(n <= 2) {
			return 1;
		} 
		return fibonacci(n - 1) + fibonacci(n - 2);
	}
